一：Python 垃圾回收机制
Python GC 主要使用引用计数（ reference counting ）来跟踪和回收垃圾。在引用
计数的基础上，通过“标记- 清除”（ mark and sweep ）解决容器对象可能产生的
循环引用问题，通过“分代回收”（ generation collection ）以空间换时间的方法
提高垃圾回收效率。
1 ，引用计数
PyObject 是每个对象必有的内容，其中ob_refcnt 就是做为引用计数。当一个对
象有新的引用时，它的ob_refcnt 就会增加，当引用它的对象被删除，它的
ob_refcnt 就会减少.引用计数为0 时，该对象生命就结束了。
优点:
1. 简单
2. 实时性
缺点:
1. 维护引用计数消耗资源
2. 循环引用
循环引用可以使一组对象的引用计数不为0，然而这些对象实际上并没有被任何外部对象所引用，它们之间只是相互引用。
这意味着不会再有人使用这组对象，应该回收这组对象所占用的内存空间，然后由于相互引用的存在，每一个对象的引用计数都不为0，
因此这些对象所占用的内存永远不会被释放。比如：
a = []
b = []
a.append(b)
b.append(a)
print a
[[[…]]]
print b
[[[…]]]
2， 标记-清除机制
基本思路是先按需分配， 等到没有空闲内存的时候从寄存器和程序栈上的引用出发，
遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然
后清扫一遍内存空间，把所有没标记的对象释放。
3 ，分代技术
分代回收的整体思想是： 将系统中的所有内存块根据其存活时间划分为不同的集合，
每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，
存活时间通常利用经过几次垃圾回收来度量。
Python 默认定义了三代对象集合，索引数越大，对象存活时间越长。
举例：
当某些内存块M 经过了3 次垃圾收集的清洗之后还存活时，我们就将内存块M 划
到一个集合A 中去，而新分配的内存都划分到集合B 中去。当垃圾收集开始工作时，
大多数情况都只对集合B 进行垃圾回收， 而对集合A 进行垃圾回收要隔相当长一段
时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。
在这个过程中，集合B 中的某些内存块由于存活时间长而会被转移到集合A 中，当
然，集合A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被
延迟。

二：阅读下面的代码，写出A0 ，A1 至An 的最终值。
A0 = dict(zip(('a','b','c','d','e'),(1,2,3,4,5)))
A1 = range(10)
A2 = [i for i in A1 if i in A0]
A3 = [A0[s] for s in A0]
A4 = [i for i in A1 if i in A3]
A5 = {i:i*i for i in A1}
A6 = [[i,i*i] for i in A1]
答案（列表解析）
A0 = {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4}
A1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
A2 = []
A3 = [1, 3, 2, 5, 4]
A4 = [1, 2, 3, 4, 5]
A5 = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
A6 = [[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]


三：下面代码会输出什么：
def f(x,l=[]):
for i in range(x):
       l.append(i*i)
       print(l)
f(2)
f(3,[3,2,1])
f(3)
答案：
[0, 1]
[3, 2, 1, 0, 1, 4]
[0, 1, 0, 1, 4]
第一个函数调用十分明显， for 循环先后将0 和1 添加至了空列表l 中。l 是变量的名字，
指向内存中存储的一个列表。第二个函数调用在一块新的内存中创建了新的列表。l 这时指
向了新生成的列表。之后再往新列表中添加0、1 和4。很棒吧。第三个函数调用的结果就
有些奇怪了。它使用了之前内存地址中存储的旧列表。这就是为什么它的前两个元素是0
和1 了。



四：谈谈RESTful架构
要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。

三、资源（Resources）

REST的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。

所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。

所谓"上网"，就是与互联网上一系列的"资源"互动，调用它的URI。

四、表现层（Representation）

"资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。

比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。

URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。

五、状态转化（State Transfer）

访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。

互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。

客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

六、综述

综合上面的解释，我们总结一下什么是RESTful架构：

　　（1）每一个URI代表一种资源；

　　（2）客户端和服务器之间，传递这种资源的某种表现层；

　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"

五、数据库的优化
1. 优化索引、SQL 语句、分析慢查询；
任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
慢查询：MySQL记录下查询超过指定时间的语句，我们将超过指定时间的SQL语句查询称为“慢查询”。

2. 设计表的时候严格根据数据库的设计范式来设计数据库；
① 将字段较多的表分解成多个表 
对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。
因为当一个表的数据量很大时，会由于存在使用频率低的字段而使查询速度变慢。
② 增加中间表 
对于经常需要联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入中间表，
然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。 

3. 使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能
节约磁盘IO；

4.避免过多的级联


